/**
 * you can use assembleRelease to build you base apk
 * use tinkerPatchRelease -POLD_APK=  -PAPPLY_MAPPING=  -PAPPLY_RESOURCE= to build patch
 * add apk from the build/backApk
 */

if (Boolean.parseBoolean(TINKER_ENABLE)) {
    apply plugin: 'com.tencent.tinker.patch'

    android {
        defaultConfig {
            buildConfigField "String", "MESSAGE", "\"I am the base apk\""
            buildConfigField "String", "TINKER_ID", "\"${PROJ_VERSION}\""
            buildConfigField "String", "PLATFORM", "\"all\""
            buildConfigField("Integer", "TINKER_TYPE", "${TINKER_TYPE}")
            // 有些库里面既包含了注解，也包含了注解处理，目前用这种变通的方法，今后可以删除
            javaCompileOptions.annotationProcessorOptions.includeCompileClasspath = true
        }
    }

    dependencies {
//        //tinker的核心库
//        implementation('com.tencent.tinker:tinker-android-lib:1.9.14.5')
//        // 可选，用于生成application类
//        implementation('com.tencent.tinker:tinker-android-anno:1.9.14.5')
        // 若使用annotation需要单独引用,对于tinker的其他库都无需再引用
        implementation("com.tinkerpatch.tinker:tinker-android-anno:1.9.14.5")
        implementation("com.tinkerpatch.sdk:tinkerpatch-android-sdk:1.2.14.5")
    }

    // 默认备份路径
    def backPath = file "${buildDir}/${TINKER_BACK_DIR}/"
    // 存放apk、R、mapping的路径
    def apkPath = file "${backPath}/${project.name}-${TINKER_VARIANT}/${TINKER_DATE}"
    // apk路径
    def oldApkFile = file "${apkPath}/${project.name}.apk"
    // mapping路径
    def oldMapping = file "${apkPath}/mapping.txt"
    // R路径
    def oldR = file "${apkPath}/R.txt"

    /**
     * 更多配置一定要参考源代码，文档很多内容都过时了
     * ../tinker/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
     */
    tinkerPatch {
        /**
         * optional，default 'true'
         * whether use tinker to build
         */
        tinkerEnable = Boolean.parseBoolean(TINKER_ENABLE)
        /**
         * necessary，default 'null'
         * the old apk path, use to diff with the new apk to build
         * add apk from the build/backApk
         */
        oldApk = hasProperty("TINKER_OLD_APK") ? TINKER_OLD_APK : oldApkFile
        /**
         * 选填，用于编译补丁apk路径。如果路径合法，即不再编译新的安装包，使用oldApk与newApk直接编译。
         */
        newApk = hasProperty("TINKER_NEW_APK") ? TINKER_NEW_APK : null
        /**
         * optional，default 'false'
         * there are some cases we may get some warnings
         * if ignoreWarning is true, we would just assert the patch process
         * case 1: minSdkVersion is below 14, but you are using dexMode with raw.
         *         it must be crash when load.
         * case 2: newly added Android Component in AndroidManifest.xml,
         *         it must be crash when load.
         * case 3: loader classes in dex.loader{} are not keep in the main dex,
         *         it must be let tinker not work.
         * case 4: loader classes in dex.loader{} changes,
         *         loader classes is ues to load patch dex. it is useless to change them.
         *         it won't crash, but these changes can't effect. you may ignore it
         * case 5: resources.arsc has changed, but we don't use applyResourceMapping to build
         */
        ignoreWarning = false

        /**
         * optional，default 'true'
         * whether sign the patch file
         * if not, you must do yourself. otherwise it can't check success during the patch loading
         * we will use the sign config with your build type
         */
        useSign = true

        /**
         * 选填，设置编译输出路径。默认在build/outputs/tinkerPatch中
         *
         * 这是代码更新过了，源码应该是`outFolder`而不是`outputFolder`
         * 因为这里会进行apk文件的解压，占据的空间比较多，就采用默认的位置，打完包在把需要的文件copy走
         */
//        outFolder = "build/outputs/tinkerPatch"

        /**
         * error: loader classes are found in old secondary dex
         * 参考：https://github.com/Tencent/tinker/issues/1309
         */
        allowLoaderInAnyDex = true
        removeLoaderForAllDex = true

        /**
         * Warning, applyMapping will affect the normal android build!
         */
        buildConfig {
            /**
             * optional，default 'null'
             * if we use tinkerPatch to build the patch apk, you'd better to apply the old
             * apk mapping file if minifyEnabled is enable!
             * Warning:
             * you must be careful that it will affect the normal assemble build!
             */
            applyMapping = hasProperty("TINKER_OLD_MAPPING") ? TINKER_OLD_MAPPING : oldMapping
            /**
             * optional，default 'null'
             * It is nice to keep the resource id from R.txt file to reduce java changes
             */
            applyResourceMapping = hasProperty("TINKER_OLD_R") ? TINKER_OLD_R : oldR

            /**
             * necessary，default 'null'
             * because we don't want to check the base apk with md5 in the runtime(it is slow)
             * tinkerId is use to identify the unique base apk when the patch is tried to apply.
             * we can use git rev, svn rev or simply versionCode.
             * we will gen the tinkerId in your manifest automatic
             *
             * 这个tinkerId会被放入patch包的meta信息中，之后和apk中buildConfig中的TINKER_ID字段进行对比
             */
            tinkerId = PROJ_VERSION

            /**
             * if keepDexApply is true, class in which dex refer to the old apk.
             * open this can reduce the dex diff file size.
             */
            keepDexApply = true

            /**
             * optional, default 'false'
             * Whether tinker should treat the base apk as the one being protected by app
             * protection tools.
             * If this attribute is true, the generated patch package will contain a
             * dex including all changed classes instead of any dexdiff patch-info files.
             */
            isProtectedApp = false

            /**
             * optional, default 'false'
             * Whether tinker should support component hotplug (add new component dynamically).
             * If this attribute is true, the component added in new apk will be available after
             * patch is successfully loaded. Otherwise an error would be announced when generating patch
             * on compile-time.
             *
             * <b>Notice that currently this feature is incubating and only support NON-EXPORTED Activity</b>
             */
            supportHotplugComponent = false
        }

        dex {
            /**
             * optional，default 'jar'
             * only can be 'raw' or 'jar'. for raw, we would keep its original format
             * for jar, we would repack dexes with zip format.
             * if you want to support below 14, you must use jar
             * or you want to save rom or check quicker, you can use raw mode also
             */
            dexMode = "jar"

            /**
             * necessary，default '[]'
             * what dexes in apk are expected to deal with tinkerPatch
             * it support * or ? pattern.
             */
            pattern = ["classes*.dex",
                       "assets/secondary-dex-?.jar"]
            /**
             * necessary，default '[]'
             * Warning, it is very very important, loader classes can't change with patch.
             * thus, they will be removed from patch dexes.
             * you must put the following class into main dex.
             * Simply, you should add your own application {@code tinker.sample.android.SampleApplication}
             * own tinkerLoader, and the classes you use in them
             *
             */
            loader = [
                    //use sample, let BaseBuildInfo unchangeable with tinker
                    "tinker.sample.android.app.BaseBuildInfo"
            ]
            /**
             * 这个官网没有写
             * 如果更改了AppLike类，就会有几个类（com.tencent.tinker.loader.*）提示被修改了但是不在忽略列表里面，导致打patch包失败
             */
            ignoreWarningLoader = [
                    "com.tencent.tinker.loader.*",
                    "tinker.sample.android.app.BaseBuildInfo"
            ]
        }

        lib {
            /**
             * optional，default '[]'
             * what library in apk are expected to deal with tinkerPatch
             * it support * or ? pattern.
             * for library in assets, we would just recover them in the patch directory
             * you can get them in TinkerLoadResult with Tinker
             */
            pattern = ["lib/*/*.so"]
        }

        res {
            /**
             * optional，default '[]'
             * what resource in apk are expected to deal with tinkerPatch
             * it support * or ? pattern.
             * you must include all your resources in apk here,
             * otherwise, they won't repack in the new apk resources.
             */
            pattern = ["res/*", "assets/*", "resources.arsc", "AndroidManifest.xml"]

            /**
             * optional，default '[]'
             * the resource file exclude patterns, ignore add, delete or modify resource change
             * it support * or ? pattern.
             * Warning, we can only use for files no relative with resources.arsc
             */
            ignoreChange = ["assets/sample_meta.txt"]

            /**
             * default 100kb
             * for modify resource, if it is larger than 'largeModSize'
             * we would like to use bsdiff algorithm to reduce patch file size
             */
            largeModSize = 100
        }

        packageConfig {
            /**
             * optional，default 'TINKER_ID, TINKER_ID_VALUE' 'NEW_TINKER_ID, NEW_TINKER_ID_VALUE'
             * package meta file gen. path is assets/package_meta.txt in patch file
             * you can use securityCheck.getPackageProperties() in your ownPackageCheck method
             * or TinkerLoadResult.getPackageConfigByName
             * we will get the TINKER_ID from the old apk manifest for you automatic,
             * other config files (such as patchMessage below)is not necessary
             */
            configField("patchMessage", "tinker is sample to use")
            /**
             * just a sample case, you can use such as sdkVersion, brand, channel...
             * you can parse it in the SamplePatchListener.
             * Then you can use patch conditional!
             */
            configField("platform", "all")
            /**
             * patch version via packageConfig
             */
            configField("patchVersion", "1.0.0")
        }
        //or you can add config filed outside, or get meta value from old apk
        //project.tinkerPatch.packageConfig.configField("test1", project.tinkerPatch.packageConfig.getMetaDataFromOldApk("Test"))
        //project.tinkerPatch.packageConfig.configField("test2", "sample")

        /**
         * if you don't use zipArtifact or path, we just use 7za to try
         */
        sevenZip {
            /**
             * optional，default '7za'
             * the 7zip artifact path, it will use the right 7za with your platform
             */
            zipArtifact = "com.tencent.mm:SevenZip:1.1.10"
            /**
             * optional，default '7za'
             * you can specify the 7za path yourself, it will overwrite the zipArtifact value
             */
//        path = "/usr/local/bin/7za"
        }
    }

    // 提前保存所有的flavors
    List<String> flavors = new ArrayList<>()
    project.android.productFlavors.each { flavor -> flavors.add(flavor.name) }
    boolean hasFlavors = flavors.size() > 0
    // 保存打包的日期
    def date = new Date().format("MMdd-HH-mm-ss")

    /**
     * 运行在assemble阶段（assembleDebug， assembleRelease）
     * 过滤出所有以`assemble`开头，并且最后内容为`variant.name`的任务， eg:
     * `assembleDebug`, `assembleMiDebug`
     * 备份*.apk, mapping.txt, R.txt文件
     */
    android.applicationVariants.all { variant ->
        // 遍历任务，对需要的任务进行选择
        tasks.all {
            // 筛选出类似`assembleDebug`(无Flavor), `assembleMiDebug`(有Flavor)的任务
            if ("assemble${variant.name.capitalize()}".equalsIgnoreCase(it.name)) {
                // 在任务完成之后添加额外内容
                it.doLast {
                    // 复制任务
                    copy {
                        // 获取到apk文件， eg： ./build/outputs/apk/mi/debug/Study-mi-debug.apk
                        from "${buildDir}/outputs/apk/${variant.dirName}/"
                        // 获取mapping文件, eg: ./build/outputs/mapping/mi/debug/mapping.txt
                        from "${buildDir}/outputs/mapping/${variant.dirName}/mapping.txt"
                        // 获取R文件, eg: ./build/intermediates/[symbols|symbol_list]/mi/debug/R.txt
                        from "${buildDir}/intermediates/symbols/${variant.dirName}/R.txt"
                        from "${buildDir}/intermediates/symbol_list/${variant.dirName}/R.txt"
                        // 只复制apk和txt文件
                        include '*.apk', 'mapping.txt', 'R.txt'
                        // 对apk文件重命名
                        rename '.*\\.apk', "${project.name}.apk"
                        // 放入目标目录， eg: ./build/backApk/app-mi-debug/0330-19-28-55
                        into "${backPath}/${project.name}-${variant.baseName}/${date}"
                    }
                }
            }
            // 筛选出类似`tinkerPatchDebug`(无Flavor), `tinkerPatchMiDebug`(有Flavor)的任务
            if ("tinkerPatch${variant.name.capitalize()}".equalsIgnoreCase(it.name)) {
                // 在任务完成之后添加额外内容
                it.doLast {
                    // 复制任务
                    copy {
                        // 获取到apk文件， eg： ./build/outputs/apk/mi/debug/Study-mi-debug.apk
                        from "${buildDir}/outputs/apk/${variant.flavorName}/tinkerPatch/${variant.dirName}/"
                        // 只复制apk和txt文件
                        include '*.apk', '*.txt'
                        // 放入目标目录， eg: ./build/backApk/app-mi-debug/0330-19-28-55/patch/0
                        def target = new File("${backPath}/${project.name}-${variant.baseName}/${TINKER_DATE}/patch")
                        target.mkdirs()
                        target = new File(target, target.listFiles().length.toString())
                        target.mkdirs()
                        into target
                    }
                    // 删除为了打包产生的文件
                    if (Boolean.parseBoolean(TINKER_PATCH_APK_CLEAN)) {
                        delete "${backPath}/${project.name}-${variant.baseName}/${date}"
                    }
                }
            }
        }
    }

    /**
     * 运行在计算完成之后
     * 通过增加任务（tinkerPatchDebug）的方式，完成一次性打出所有Flavor的补丁包的效果
     *
     * 步骤：(以小米渠道打包为例）
     * 1、在执行`processMiDebugManifest`任务前先设置`tinkerPatch`中的apk,mapping,R这3个文件的路径
     * 2、执行`processMiDebugManifest`任务
     * 3、执行`tinkerPatchMiDebug`
     */
    project.afterEvaluate {
        if (hasFlavors) {
            // 添加任务
            task(tinkerPatchRelease) {
                group = 'tinker'
                flavors.each { flavor -> dependsOn assemblePatch(flavor, "release", backPath, date) }
            }

            // 添加任务
            task(tinkerPatchDebug) {
                group = 'tinker'
                flavors.each { flavor -> dependsOn assemblePatch(flavor, "debug", backPath, date) }
            }
        }
    }
}

/**
 * 设置`tinkerPatch`中的apk,mapping,R这3个文件的路径
 * @param flavor 需要小写
 * @param type =[debug|release] 需要小写
 * @return 返回`tinkerPatchMiDebug`的任务
 */
def assemblePatch(String flavor, String type, Object backPath, Object date) {
    // 在执行`processMiDebugManifest`任务前先设置`tinkerPatch`中的apk,mapping,R这3个文件的路径
    def preAssembleTask = tasks.getByName("process${flavor.capitalize()}${type.capitalize()}Manifest")
    preAssembleTask.doFirst {
        def oldPath = "${backPath}/${project.name}-${flavor}-${type}/${TINKER_DATE}"
        project.tinkerPatch.oldApk = "${oldPath}/${project.name}.apk"
        project.tinkerPatch.buildConfig.applyMapping = "${oldPath}/mapping.txt"
        project.tinkerPatch.buildConfig.applyResourceMapping = "${oldPath}/R.txt"
    }
    // 返回`tinkerPatchMiDebug`任务
    return tasks.getByName("tinkerPatch${flavor.capitalize()}${type.capitalize()}")
}