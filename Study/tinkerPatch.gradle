apply plugin: 'tinkerpatch-support'

def backPath = file("${buildDir}/backApk/")
def name = "${project.name}-${TINKER_VARIANT}"
def pathPrefix = "${backPath}/${project.name}-${PROJ_VERSION}-${TINKER_BASE_APK_DATE}/${TINKER_VARIANT}/"

/**
 * 对于插件各参数的详细解析请参考
 * http://tinkerpatch.com/Docs/SDK
 */
tinkerpatchSupport {
    /** 可以在debug的时候关闭 tinkerPatch **/
    /** 当disable tinker的时候需要添加multiDexKeepProguard和proguardFiles,
     这些配置文件本身由tinkerPatch的插件自动添加，当你disable后需要手动添加
     你可以copy本示例中的proguardRules.pro和tinkerMultidexKeep.pro,
     需要你手动修改'tinker.sample.android.app'本示例的包名为你自己的包名, com.xxx前缀的包名不用修改
     **/
    tinkerEnable = true
    /**
     * 是否反射 Application 实现一键接入；一般来说，接入 Tinker 我们需要改造我们的 Application, 若这里为 true， 即我们无需对应用做任何改造即可接入。
     */
    reflectApplication = false
    /**
     * 是否开启加固模式，只能在APK将要进行加固时使用，否则会patch失败。
     * 如果只在某个渠道使用了加固，可使用多flavors配置
     **/
    protectedApp = false
    /**
     * 实验功能
     * 补丁是否支持新增 Activity (新增Activity的exported属性必须为false)
     **/
    supportComponent = true
    /**
     * 将每次编译产生的 apk/mapping.txt/R.txt 归档存储的位置
     */
    autoBackupApkPath = "${backPath}"

    /**
     * 在 TinkerPatch 平台 申请的 appkey, 例如 sample 中的 'f828475486f91936'
     */
    appKey = "${TINKER_PATCH_APP_KEY}"

    /** 注意: 若发布新的全量包, appVersion一定要更新 **/
    appVersion = "${PROJ_VERSION}"
    /**
     * 基准包的文件路径, 对应 tinker 插件中的 oldApk 参数;编译补丁包时，必需指定基准版本的 apk，默认值为空，则表示不是进行补丁包的编译。
     */
    baseApkFile = "${pathPrefix}/${name}.apk"
    /**
     * 基准包的 Proguard mapping.txt 文件路径, 对应 tinker 插件 applyMapping 参数；
     * 在编译新的 apk 时候，我们希望通过保持基准 apk 的 proguard 混淆方式，从而减少补丁包的大小。
     * 这是强烈推荐的，编译补丁包时，我们推荐输入基准 apk 生成的 mapping.txt 文件
     */
    baseProguardMappingFile = "${pathPrefix}/${name}-mapping.txt"
    /**
     * 基准包的资源 R.txt 文件路径, 对应 tinker 插件 applyResourceMapping 参数；
     * 在编译新的apk时候，我们希望通基准 apk 的 R.txt 文件来保持 Resource Id 的分配，
     * 这样不仅可以减少补丁包的大小，同时也避免由于 Resource Id 改变导致 remote view 异常。
     */
    baseResourceRFile = "${pathPrefix}/${name}-R.txt"

    /**
     *  若有编译多flavors需求, 可以参照： https://github.com/TinkerPatch/tinkerpatch-flavors-sample
     *  注意: 除非你不同的flavor代码是不一样的,不然建议采用zip comment或者文件方式生成渠道信息（相关工具：walle 或者 packer-ng）
     **/
}

/**
 * 用于用户在代码中判断tinkerPatch是否被使能
 */
android {
    defaultConfig {
        buildConfigField "boolean", "TINKER_PATCH_ENABLE", "${tinkerpatchSupport.tinkerEnable}"
        buildConfigField "String", "PLATFORM", "\"all\""
        buildConfigField("Integer", "TINKER_TYPE", "${TINKER_TYPE}")
        // 有些库里面既包含了注解，也包含了注解处理，目前用这种变通的方法，今后可以删除
        javaCompileOptions.annotationProcessorOptions.includeCompileClasspath = true
    }
}

dependencies {
    // 若使用annotation需要单独引用,对于tinker的其他库都无需再引用
    implementation("com.tinkerpatch.tinker:tinker-android-anno:1.9.14.5")
    implementation("com.tinkerpatch.sdk:tinkerpatch-android-sdk:1.2.14.5")
}

/**
 * 一般来说,我们无需对下面的参数做任何的修改
 * 对于各参数的详细介绍请参考:
 * https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97
 */
tinkerPatch {
    /**
     * optional，default 'false'
     * there are some cases we may get some warnings
     * if ignoreWarning is true, we would just assert the patch process
     * case 1: minSdkVersion is below 14, but you are using dexMode with raw.
     *         it must be crash when load.
     * case 2: newly added Android Component in AndroidManifest.xml,
     *         it must be crash when load.
     * case 3: loader classes in dex.loader{} are not keep in the main dex,
     *         it must be let tinker not work.
     * case 4: loader classes in dex.loader{} changes,
     *         loader classes is ues to load patch dex. it is useless to change them.
     *         it won't crash, but these changes can't effect. you may ignore it
     * case 5: resources.arsc has changed, but we don't use applyResourceMapping to build
     */
    ignoreWarning = false

    /**
     * optional，default 'true'
     * whether sign the patch file
     * if not, you must do yourself. otherwise it can't check success during the patch loading
     * we will use the sign config with your build type
     */
    useSign = true

    /**
     * error: loader classes are found in old secondary dex
     * 参考：https://github.com/Tencent/tinker/issues/1309
     */
    allowLoaderInAnyDex = true
    removeLoaderForAllDex = true

    dex {
        /**
         * optional，default 'jar'
         * only can be 'raw' or 'jar'. for raw, we would keep its original format
         * for jar, we would repack dexes with zip format.
         * if you want to support below 14, you must use jar
         * or you want to save rom or check quicker, you can use raw mode also
         */
        dexMode = "jar"

        /**
         * necessary，default '[]'
         * what dexes in apk are expected to deal with tinkerPatch
         * it support * or ? pattern.
         */
        pattern = ["classes*.dex", "assets/secondary-dex-?.jar"]
        /**
         * necessary，default '[]'
         * Warning, it is very very important, loader classes can't change with patch.
         * thus, they will be removed from patch dexes.
         * you must put the following class into main dex.
         * Simply, you should add your own application {@code tinker.sample.android.SampleApplication}
         * own tinkerLoader, and the classes you use in them
         *
         */
        loader = [
                //use sample, let BaseBuildInfo unchangeable with tinker
                "tinker.sample.android.app.BaseBuildInfo"
        ]
    }
    lib {
        /**
         * optional，default '[]'
         * what library in apk are expected to deal with tinkerPatch
         * it support * or ? pattern.
         * for library in assets, we would just recover them in the patch directory
         * you can get them in TinkerLoadResult with Tinker
         */
        pattern = ["lib/*/*.so"]
    }

    res {
        /**
         * optional，default '[]'
         * what resource in apk are expected to deal with tinkerPatch
         * it support * or ? pattern.
         * you must include all your resources in apk here,
         * otherwise, they won't repack in the new apk resources.
         */
        pattern = ["res/*", "r/*", "assets/*", "resources.arsc", "AndroidManifest.xml"]

        /**
         * optional，default '[]'
         * the resource file exclude patterns, ignore add, delete or modify resource change
         * it support * or ? pattern.
         * Warning, we can only use for files no relative with resources.arsc
         */
        ignoreChange = ["assets/sample_meta.txt"]

        /**
         * default 100kb
         * for modify resource, if it is larger than 'largeModSize'
         * we would like to use bsdiff algorithm to reduce patch file size
         */
        largeModSize = 100
    }

    packageConfig {
        /**
         * optional，default 'TINKER_ID, TINKER_ID_VALUE' 'NEW_TINKER_ID, NEW_TINKER_ID_VALUE'
         * package meta file gen. path is assets/package_meta.txt in patch file
         * you can use securityCheck.getPackageProperties() in your ownPackageCheck method
         * or TinkerLoadResult.getPackageConfigByName
         * we will get the TINKER_ID from the old apk manifest for you automatic,
         * other config files (such as patchMessage below)is not necessary
         */
        configField("patchMessage", "tinker is sample to use")
        /**
         * just a sample case, you can use such as sdkVersion, brand, channel...
         * you can parse it in the SamplePatchListener.
         * Then you can use patch conditional!
         */
        configField("platform", "all")
        /**
         * patch version via packageConfig
         */
        configField("patchVersion", "1.0.0")
    }

    /**
     * if you don't use zipArtifact or path, we just use 7za to try
     */
    sevenZip {
        /**
         * optional，default '7za'
         * the 7zip artifact path, it will use the right 7za with your platform
         */
//            zipArtifact = "com.tencent.mm:SevenZip:1.1.10"
        /**
         * optional，default '7za'
         * you can specify the 7za path yourself, it will overwrite the zipArtifact value
         */
//        path = "/usr/local/bin/7za"
    }

    buildConfig {
        /**
         * if keepDexApply is true, class in which dex refer to the old apk.
         * open this can reduce the dex diff file size.
         */
        keepDexApply = true

        /**
         * optional, default 'false'
         * Whether tinker should treat the base apk as the one being protected by app
         * protection tools.
         * If this attribute is true, the generated patch package will contain a
         * dex including all changed classes instead of any dexdiff patch-info files.
         */
        isProtectedApp = false

        /**
         * optional, default 'false'
         * Whether tinker should support component hotplug (add new component dynamically).
         * If this attribute is true, the component added in new apk will be available after
         * patch is successfully loaded. Otherwise an error would be announced when generating patch
         * on compile-time.
         *
         * <b>Notice that currently this feature is incubating and only support NON-EXPORTED Activity</b>
         */
        supportHotplugComponent = false
    }
}
